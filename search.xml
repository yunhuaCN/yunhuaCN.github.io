<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>哨兵决策说明</title>
      <link href="/2023/05/16/shao-bing-jue-ce-shuo-ming/"/>
      <url>/2023/05/16/shao-bing-jue-ce-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h1 id="哨兵决策说明"><a href="#哨兵决策说明" class="headerlink" title="哨兵决策说明"></a>哨兵决策说明</h1><h2 id="1-击打优先级"><a href="#1-击打优先级" class="headerlink" title="1.击打优先级"></a>1.击打优先级</h2><p>对于全自动机器人来说，同时识别到多个敌方机器人之后判断优先击打哪个极为重要。</p><p>上赛季思路：</p><ul><li>不击打工程机器人</li><li>按一定的规则分配权重计算优先级</li><li>不击打远距离（敌方高地之后）敌人</li></ul><p>权重计算优先级：根据不同的<code>兵种</code>，敌方车辆与哨兵之间的<code>距离</code>设置不同的权重，最终综合分析进行筛选</p><p>本赛季建议：</p><ol><li>可结合敌方车辆剩余血量进行优先级计算</li><li>结合雷达针对雷达划定的敏感区域来综合判断击打目标</li></ol><h2 id="2-发弹控制逻辑"><a href="#2-发弹控制逻辑" class="headerlink" title="2.发弹控制逻辑"></a>2.发弹控制逻辑</h2><p>将对连续出现多次的敌方车辆划入击打目标范围内，如只出现十几帧，则没必要击打，会浪费子弹并且会导致云台抖动。然后最主要的就是通用的发弹控制逻辑，就陈君他们那种，不知道咱们队里现在有没有。</p><h2 id="3-根据不同的距离使用不同的射频"><a href="#3-根据不同的距离使用不同的射频" class="headerlink" title="3.根据不同的距离使用不同的射频"></a>3.根据不同的距离使用不同的射频</h2><h2 id="4-本赛季个人建议"><a href="#4-本赛季个人建议" class="headerlink" title="4.本赛季个人建议"></a>4.本赛季个人建议</h2><p>若云台还是绕yaw轴转动</p><p>可以考虑哨兵在进攻与防守模式之间使用不同的决策。</p><p>进攻时可让云台360°转动，防守时云台180°转动。</p><p>鉴于今年规则以及哨兵发弹量的改变，可以尝试在前哨站未破的情况下让哨兵充当干扰敌方打符的角色。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;击打策略模块    &#x2F;&#x2F;获取各装甲板距离    vector&lt;Point2f&gt; _pts;    vector&lt;Solver&gt; solves;    int num &#x3D; 0;    for (int i &#x3D; 0; i &lt; _armor_boxes.size(); i++)    &#123;        _armor_boxes[i].getPoints(_pts);        Solver temp_solver;        temp_solver.solve(_pts, _armor_boxes[i].type);        solves.push_back(temp_solver);        _armor_boxes[i].armor_distance &#x3D; solves[i].distance;        &#x2F;&#x2F;cout &lt;&lt; &quot;distancesdsdsd&quot; &lt;&lt; _armor_boxes[i].armor_distance &lt;&lt; endl;        if (solves[i].distance &lt; 3)            _armor_boxes[i].ShootParam.k3 &#x3D; _armor_boxes[i].ShootParam.k3_1;        else if (solves[i].distance &gt;&#x3D; 3 &amp;&amp; solves[i].distance &lt;&#x3D; 5)            _armor_boxes[i].ShootParam.k3 &#x3D; _armor_boxes[i].ShootParam.k3_2;        else            _armor_boxes[i].ShootParam.k3 &#x3D; _armor_boxes[i].ShootParam.k3_3;        &#x2F;&#x2F;兵种识别        if (_armor_boxes[i].id &#x3D;&#x3D; 1)            _armor_boxes[i].ShootParam.k2 &#x3D; _armor_boxes[i].ShootParam.k2_1;        else if (_armor_boxes[i].id &#x3D;&#x3D; 2)            &#x2F;&#x2F;_armor_boxes[i].ShootParam.k2 &#x3D; _armor_boxes[i].ShootParam.k2_2;        &#123;            state &#x3D; ArmorState::LOST;            return false;        &#125;        else if (_armor_boxes[i].id &#x3D;&#x3D; 3)            _armor_boxes[i].ShootParam.k2 &#x3D; _armor_boxes[i].ShootParam.k2_3;        else if (_armor_boxes[i].id &#x3D;&#x3D; 4)            _armor_boxes[i].ShootParam.k2 &#x3D; _armor_boxes[i].ShootParam.k2_4;        else if (_armor_boxes[i].id &#x3D;&#x3D; 5)            _armor_boxes[i].ShootParam.k2 &#x3D; _armor_boxes[i].ShootParam.k2_5;        else            _armor_boxes[i].ShootParam.k2 &#x3D; -100;        &#x2F;&#x2F;装甲板大小        if (_armor_boxes[i].type &#x3D;&#x3D; BIG)            _armor_boxes[i].ShootParam.k1 &#x3D; _armor_boxes[i].ShootParam.k1_1;        else            _armor_boxes[i].ShootParam.k1 &#x3D; _armor_boxes[i].ShootParam.k1_2;        &#x2F;&#x2F; sum        _armor_boxes[i].ShootParam.k &#x3D; _armor_boxes[i].ShootParam.k1 + _armor_boxes[i].ShootParam.k2 + _armor_boxes[i].ShootParam.k3;        if (_armor_boxes[i].ShootParam.k &gt; _armor_boxes[0].ShootParam.k)            num &#x3D; i;    &#125;    if (_armor_boxes[num].id &gt; 5 || _armor_boxes[num].id &lt; 1)    &#123;        state &#x3D; ArmorState::LOST;        return false;    &#125;    else    &#123;        target &#x3D; _armor_boxes[num];        target.timestamp &#x3D; time_;                   box &#x3D; armor_boxes[num];        cout &lt;&lt; &quot;shoot_id&quot; &lt;&lt; target.id &lt;&lt; endl;    &#125;    if(solves[num].distance &lt;&#x3D; 2.5)    &#123;        predictor.bullet_speed &#x3D; predictor.bullet_speed_2;    &#125;    else    &#123;        predictor.bullet_speed &#x3D; predictor.bullet_speed_1;    &#125;    &#x2F;&#x2F; end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;距离射频决策模块   if (detector.target.armor_distance &lt;&#x3D; 3)   &#123;       shoot_time &#x3D; 100;       shoot_stage &#x3D; ShootStage::FIRING_IN_BURSTS_1;   &#125;   else if (detector.target.armor_distance &gt;&#x3D; 5.5)   &#123;       shoot_time &#x3D; 300;       shoot_stage &#x3D; ShootStage::DARTLE;   &#125;   else if(detector.target.armor_distance &#x3D;&#x3D; 0)   &#123;       shoot_stage &#x3D; 0;   &#125;   else   &#123;       shoot_time &#x3D; 200;       shoot_stage &#x3D; ShootStage::FIRING_IN_BURSTS_2;   &#125;   cout &lt;&lt; &quot;shoot_stage&quot; &lt;&lt; shoot_stage &lt;&lt; endl;   send_mutex.unlock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> RoboMaster </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RoboMaster </tag>
            
            <tag> 哨兵 </tag>
            
            <tag> 全自动机器人 </tag>
            
            <tag> 决策说明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-散列查找算法</title>
      <link href="/2023/04/17/cha-zhao-suan-fa-san-lie-cha-zhao-suan-fa/"/>
      <url>/2023/04/17/cha-zhao-suan-fa-san-lie-cha-zhao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="3-7-散列查找（hash查找）"><a href="#3-7-散列查找（hash查找）" class="headerlink" title="3.7 散列查找（hash查找）"></a>3.7 散列查找（hash查找）</h2><h3 id="3-7-1-基本概念"><a href="#3-7-1-基本概念" class="headerlink" title="3.7.1 基本概念"></a>3.7.1 基本概念</h3><p>散列函数</p><p>在进行查找时，在记录的存储位置与它的关键字之间建立一个确定的对应关系h,以线性表中每个元素的关键字K为自变量，通过函数h(K)计算出该元素的存储位置，我们将h函数称为散列函数或<a href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0?fromModule=lemma_inlink">哈希函数</a>。h(K)的值称为散列地址或哈希地址。 [1] <strong>例：</strong></p><p>假定一个线性表为A&#x3D;(18,75,60,43,54,90,46)，选取散列函数为：</p><p>h(K)&#x3D;K%m 取m&#x3D;13</p><p>则得每个元素散列地址：</p><p>h(18)&#x3D;18 % 13&#x3D;5 h(75)&#x3D;75 % 13&#x3D;10 h(60)&#x3D;60 % 13&#x3D;8 h(43)&#x3D;43 % 13&#x3D;4</p><p>h(54)&#x3D;54 % 13&#x3D;2 h(90)&#x3D;90 % 13&#x3D;12 h(46)&#x3D;46 % 13&#x3D;7</p><p>根据散列地址，实现元素的存储映象H[m]：</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr></thead><tbody><tr><td>H</td><td></td><td></td><td>54</td><td></td><td>43</td><td>18</td><td></td><td>46</td><td>60</td><td></td><td>75</td><td></td><td>90</td></tr></tbody></table><p><strong>冲突：</strong>在实际应用中，通常可能出现一个待插入元素的散列地址单元已被占用情况，使得该元素无法直接存入此单元，这种情况称为冲突。</p><p><strong>同义词：</strong>具有不同关键字而具有相同散列地址的元素称为同义词，即key1≠key2，但h(key1)&#x3D;h(key2)。由同义词引起的冲突称作同义词冲突。</p><p>例：如向下表中再插入元素70时，70%13&#x3D;5，则出现了冲突</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr></thead><tbody><tr><td>H</td><td></td><td></td><td>54</td><td></td><td>43</td><td>18</td><td></td><td>46</td><td>60</td><td></td><td>75</td><td></td><td>90</td></tr></tbody></table><p>装填因子(α)：指散列表中已存入的元素数n与散列表空间大小m的比值,即：α&#x3D;n&#x2F;m。当α越小时，冲突可能性就越小，但同时，存储空间利用率就越低。</p><p>散列表：根据设定的哈希函数及处理冲突的方法将一组关键字映象到一个有限的连续的地址集上，即把记录存放在表中映象的位置上，这种表便称为散列表(哈希表)。</p><p>一个散列表的好坏与三个因素有关：</p><ul><li>装填因子</li><li>所采用的散列函数</li><li>解决冲突的方法</li></ul><h3 id="3-7-2-散列函数"><a href="#3-7-2-散列函数" class="headerlink" title="3.7.2 散列函数"></a>3.7.2 散列函数</h3><p>构造散列函数的目标是使散列地址尽可能均匀分布在散列空间上，同时使计算尽可能简单，以节省计算时间。</p><h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><p>以关键字K本身或关键字加上某个数值常量C作为散列地址的方法，对应的散列函数：<br>$$<br>h(K) &#x3D; K+C(C为常数)<br>$$</p><h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>以关键字K除以散列长度m所得余数作为散列地址的方法，对应的散列函数：<br>$$<br>h(K)&#x3D;K 取余 m \<br>m:散列表长<br>$$</p><h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><p>当关键码的位数很多时，可以通过对关键码的各位进行分析，丢掉分布不均的位，留下分布均与的位作为散列值。数字分析法只适合于静态的关键码值集合，当关键码值发生变化后，必须重新进行数字分析。这无疑限制了数字分析法在实际中的应用。</p><p><strong>例：</strong>有一组关键字如下：</p><p>92326875</p><p>92739628</p><p>92343634</p><p>92706816</p><p>92774638</p><p>92381262</p><p>92394220</p><p>通过分析：每个关键字从左到右第1、2、3位和第6位取值较集中，不宜作散列地址，其余的第4、5、7、8位取值分散，可以选择，若取最后两位作散列地址，得：</p><p><strong>(2,75,28,34,16,38,62,20)</strong></p><h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><p>取关键字平方的中间几位作为散列地址的方法，由平方取中法得到的散列地址同关键字的每一位都有关，使得散列地址有较好分散性。</p><p>它适用于关键字中每一位取值都不够分散或者较分散的位数小于散列地址所需要的位数的情况。</p><h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><p>首先将关键字分割成位数相同的几段(最后一段位数可少一些)，然后将它们的叠加和(舍去最高位进位)作为散列地址的方法。</p><h4 id="随机乘数法"><a href="#随机乘数法" class="headerlink" title="随机乘数法"></a>随机乘数法</h4><p>随机乘数法使用一个随机实数f(0≤f&lt;1)。成绩f*key的分数部分在0―1之间，用这个分数部分的值与n（散列表的长度）相乘，乘积的整数部分就是对应的散列值，显然这个散列值落在0—n-1之间。</p><h4 id="基数转换法"><a href="#基数转换法" class="headerlink" title="基数转换法"></a>基数转换法</h4><p>将关键码值看成是在另一个基数数制上的书，然后把它转化成原来基数上的数，再选择其中的若干位作为散列值。一般取大于原来基数的数作为转换的基数，并且两个基数应该是互素的。</p><p>例子：采用基数转换法，计算十进制关键码值key&#x3D;852422241的散列值，取转换基数为13，则有：&#x3D;8 * 5 *</p><p>取转换后的数值的中间4为数字作为散列值，于是Hash(key)&#x3D;0789。</p><p>引用：</p><blockquote><p>1.<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE/4146554?fr=aladdin">散列查找</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 散列查找算法 </tag>
            
            <tag> HashTable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-分块查找算法</title>
      <link href="/2023/04/17/cha-zhao-suan-fa-fen-kuai-cha-zhao-suan-fa/"/>
      <url>/2023/04/17/cha-zhao-suan-fa-fen-kuai-cha-zhao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="3-6-分块查找"><a href="#3-6-分块查找" class="headerlink" title="3.6 分块查找"></a>3.6 分块查找</h2><h3 id="3-6-1-简介"><a href="#3-6-1-简介" class="headerlink" title="3.6.1 简介"></a>3.6.1 简介</h3><p>分块查找是折半查找和顺序查找的一种改进方法，分块查找由于只要求索引表是<code>有序</code>的，对块内节点没有排序要求，因此特别适合于<code>j节点动态变化</code>的情况。</p><p>分块查找是折半查找和顺序查找的一种改进方法，折半查找虽然具有很好的性能，但其前提条件时线性表顺序存储而且按照关键码排序，这一前提条件在结点树很大且表元素动态变化时是难以满足的。而顺序查找可以解决表元素动态变化的要求，但查找效率很低。如果既要保持对线性表的查找具有较快的速度，又要能够满足表元素动态变化的要求，则可采用分块查找的方法。</p><p>分块查找的速度虽然不如折半查找算法，但比顺序查找算法快得多，同时又不需要对全部节点进行排序。当节点很多且块数很大时，对索引表可以采用折半查找，这样能够进一步提高查找的速度。 [1] </p><p>分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况。当增加或减少节以及节点的关键码改变时，只需将该节点调整到所在的块即可。在空间复杂性上，分块查找的主要代价是增加了一个辅助数组。</p><p>需要注意的是，当节点变化很频繁时，可能会导致块与块之间的节点数相差很大，没写快具有很多节点，而另一些块则可能只有很少节点，这将会导致查找效率的下降。</p><h3 id="3-6-2-算法描述"><a href="#3-6-2-算法描述" class="headerlink" title="3.6.2 算法描述"></a>3.6.2 算法描述</h3><p>分块查找要求把一个大的线性表分解成若干块，每块中的节点可以任意存放，但块与块之间必须排序。假设是按关键码值非递减的，那么这种块与块之间必须满足已排序要求，实际上就是对于任意的i，第i块中的所有节点的关键码值都必须小于第i+1块中的所有节点的关键码值。此外，还要建立一个索引表，把每块中的最大关键码值作为索引表的关键码值，按块的顺序存放到一个辅助数组中，显然这个辅助数组是按关键码值费递减排序的。查找时，首先在索引表中进行查找，确定要找的节点所在的块。由于索引表是排序的，因此，对索引表的查找可以采用顺序查找或折半查找；然后，在相应的块中采用顺序查找，即可找到对应的节点。</p><p>分块查找在现实生活中也很常用。例如，一个学校有很多个班级，每个班级有几十个学生。给定一个学生的学号，要求查找这个学生的相关资料。显然，每个班级的学生档案是分开存放的，没有任何两个班级的学生的学号是交叉重叠的，那么最好的查找方法实现确定这个学生所在的班级，然后再在这个学生所在班级的学生档案中查找这个学生的资料。上述查找学生资料的过程，实际上就是一个典型的分块查找。</p><h3 id="3-6-3-过程"><a href="#3-6-3-过程" class="headerlink" title="3.6.3 过程"></a>3.6.3 过程</h3><ul><li><p>先选取<strong>各块</strong>中的<strong>最大关键字</strong>构成一个<strong>索引表</strong>；</p></li><li><p>查找分两个部分：先对索引表进行<strong>二分查找</strong>或<strong>顺序查找</strong>，以<strong>确定待查记录</strong>在<strong>哪一块</strong>中；然后，在已确定的块中用<strong>顺序法</strong>进行查找。</p><p>  示例</p><p>  <img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/1.png" alt="分块查找算法实例"></p></li><li><p>在索引表中确定自己待查记录所在的块。由于块间有序，即索引表中的元素是有序的，故可以采用折半查找或顺序查找索引表。</p></li><li><p>在块内顺序查找该待查记录。由于块内无序，故只能采用顺序查找</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 分块查找 </tag>
            
            <tag> BlockingSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-快速排序算法</title>
      <link href="/2023/04/16/cha-zhao-suan-fa-kuai-su-pai-xu-suan-fa/"/>
      <url>/2023/04/16/cha-zhao-suan-fa-kuai-su-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="3-5-快速排序"><a href="#3-5-快速排序" class="headerlink" title="3.5 快速排序"></a>3.5 快速排序</h2><h3 id="3-5-1-简介"><a href="#3-5-1-简介" class="headerlink" title="3.5.1 简介"></a>3.5.1 简介</h3><p>快速排序是通过比较和交换位置来排序的排序算法，是对冒泡算法的一种优化。当数据量比较大的时候，推荐使用快速排序。快速排序的思想是：通过一次排序将无序的数据分为两个独立部分，其中一部分数据的值均比另一部分要小，再对这两部分分别进行排序，使得整个序列有序。简单来说，就是从所有数据中取一个基准值，不大于该基准值的为一部分，大于基准值的为一部分，再在这两部分中分别取基准值再继续分别分为两部分，以此类推，直到剩下的部分只有一个元素，则结束。</p><h3 id="3-5-2-步骤"><a href="#3-5-2-步骤" class="headerlink" title="3.5.2 步骤"></a>3.5.2 步骤</h3><p>快速排序的两种方法：填坑法和前后指针法</p><p>填坑法步骤：</p><p>取序列A中第一个元素为基准值，并且取两个索引i&#x3D;0,j&#x3D;n-1，准备临时变量temp &#x3D; A[i];<br>从右开始寻找小于基准值temp的数（j– &amp;&amp; j &gt; i），得到值A[j]，填坑：A[i]&#x3D;A[j]<br>从左开始寻找不小于基准值temp的数（i++ &amp;&amp;  j&gt;i），得到值A[i]，填坑：A[j]&#x3D;A[i]<br>重复操作2和操作3，直到i&#x3D;&#x3D;j，则A[i]&#x3D;temp<br>将序列分为0 ~ i-1 和i+1 ~ n-1两部分，继续重复步骤1、2、3、4，直到最后的序列只剩下一个元素。<br>填坑法的重点：不动的指针所指的位置是坑位</p><p>如图：</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png" alt="img"></p><p>前后指针法的步骤：</p><p>取序列A中第一个元素为基准值，并且取两个索引i&#x3D;0,j&#x3D;n-1，准备临时变量begin&#x3D; i;<br>从右开始寻找不大于基准值temp的数（j– &amp;&amp; j &gt; i），得到值A[j]<br>从左开始寻找大于基准值temp的数（i++ &amp;&amp;  j&gt;i），得到值A[i]，交换值A[i]和值A[j]<br>重复操作2和操作3，直到i&#x3D;&#x3D;j，交换A[i]和A[begin]的值<br>将序列分为0 ~ i-1 和i+1 ~ n-1两部分，继续重复步骤1、2、3、4，直到最后的序列只剩下一个元素。<br>如图：</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png" alt="img"></p><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3 总结"></a>3.5.3 总结</h3><p>快速排序是一种分而治之的思想，通过基准值将序列划分为两段小序列，然后继续划分，直到划分到只有一个元素或者为空的序列，结束继续划分。其最坏时间复杂度是O(n²)，平均的时间复杂度为O(nlogn)，空间复杂度为O(logn)，是一种不稳定算法。</p><h3 id="3-5-4-快速查找"><a href="#3-5-4-快速查找" class="headerlink" title="3.5.4 快速查找"></a>3.5.4 快速查找</h3><p>和快速排序是一个思想</p><p>1.确定一个分界点<br>2.调整区间<br>3.递归处理左右两段<br>问题是，现在只要找到第k个数，所以不需要完全做完左右两个区间的调整。<br>于是判断第k个数在左边还是右边，只需要处理一边即可</p><p>引用：</p><blockquote><p>1.<a href="http://t.csdn.cn/M30up">快速排序详解</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> QuickSort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-二分查找算法</title>
      <link href="/2023/04/16/cha-zhao-suan-fa-er-fen-cha-zhao-suan-fa/"/>
      <url>/2023/04/16/cha-zhao-suan-fa-er-fen-cha-zhao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="3-4-折半查找（二分查找法）"><a href="#3-4-折半查找（二分查找法）" class="headerlink" title="3.4 折半查找（二分查找法）"></a>3.4 折半查找（二分查找法）</h2><h3 id="3-4-1-简介"><a href="#3-4-1-简介" class="headerlink" title="3.4.1 简介"></a>3.4.1 简介</h3><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fromModule=lemma_inlink">线性表</a>必须采用<a href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/1347176?fromModule=lemma_inlink">顺序存储结构</a>，而且表中元素按关键字有序排列。</p><h3 id="3-4-2-查找过程"><a href="#3-4-2-查找过程" class="headerlink" title="3.4.2 查找过程"></a>3.4.2 查找过程</h3><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><p>详解原理：</p><blockquote><ol><li>设置查找区间：low &#x3D; 0；high&#x3D; n；</li><li>若查找区间[low, high]不存在，则查找失败；否则转步骤3</li><li>取中间位mid &#x3D; (low + high) &#x2F; 2；比较 target 与 arr[mid]，有以下三种情况：<br>         3.1 若 target &lt; arr[mid]，则high &#x3D; mid - 1；查找在左半区间进行，转步骤2；<br>         3.2 若 target &gt; arr[mid]，则low &#x3D; mid + 1；查找在右半区间进行，转步骤2；<br>         3.3 若 target &#x3D; arr[mid]，则查找成功，返回 mid 值；</li></ol></blockquote><h3 id="3-4-3-算法要求"><a href="#3-4-3-算法要求" class="headerlink" title="3.4.3 算法要求"></a>3.4.3 算法要求</h3><p>1.必须采用顺序存储结构</p><p>2.必须按关键字大小有序排列</p><h3 id="3-4-4-二分查找动画演示"><a href="#3-4-4-二分查找动画演示" class="headerlink" title="3.4.4 二分查找动画演示"></a>3.4.4 二分查找动画演示</h3><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/1.gif" alt="img"></p><p>可以看出 二分查找 在查找数字 <code>37</code> 时只需3次，而 顺序查找 在查找<code>37</code>时需要12次。 </p><p>二分查找<strong>最好时间复杂度</strong>是<img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/2.gif" alt="img"></p><p>二分查找<strong>最坏时间复杂度</strong>是<img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/3.gif" alt="img"></p><p>引用：</p><blockquote><p>1.<a href="http://t.csdn.cn/lUyaF">查找算法：二分查找</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> BinarySearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-顺序查找算法</title>
      <link href="/2023/04/16/cha-zhao-suan-fa-shun-xu-cha-zhao-suan-fa/"/>
      <url>/2023/04/16/cha-zhao-suan-fa-shun-xu-cha-zhao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="3-3-顺序查找"><a href="#3-3-顺序查找" class="headerlink" title="3.3 顺序查找"></a>3.3 顺序查找</h2><p>顺序查找算法又称顺序搜索算法或者线性搜索算法，，是所有查找算法中最基本、最简单的，对应的时间复杂度为O(n)。</p><p>此算法用于在一系列数中寻找一个数或者一串字符串中寻找一个字符。</p><p>顺序查找算法就是用第一个元素开始逐个与目标元素对比。</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/1.gif" alt="img"></p><p>引用：</p><blockquote><p>1.<a href="http://t.csdn.cn/D29X9">顺序查找算法</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 顺序查找算法 </tag>
            
            <tag> SeqSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-朴素匹配算法</title>
      <link href="/2023/04/16/cha-zhao-suan-fa-po-su-pi-pei-suan-fa/"/>
      <url>/2023/04/16/cha-zhao-suan-fa-po-su-pi-pei-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="3-2-朴素匹配算法"><a href="#3-2-朴素匹配算法" class="headerlink" title="3.2 朴素匹配算法"></a>3.2 朴素匹配算法</h2><p>朴素匹配算法又称暴力匹配算法</p><p>假设我们要从 主字符串goodgoogle 中匹配  子字符串google<br> 朴素模式匹配算法就是 通过从主字符的头部开始 一次循环匹配的字符串的挨个字符   如果不通过  则主字符串头部位置遍历位置+1  在依次遍历子字符串的字符</p><p>匹配过程<br> 主字符串从第一位开始 取出g   子字符串取出第一位 g  匹配     进入子循环<br> 取出o              取出o                  匹配<br> 取出o              取出o                  匹配<br> 取出d              取出g                  不匹配    主字符串遍历位置+1</p><p>主字符串从第二位开始 取出o  子字符串取出第一位 g  不匹配        主字符串遍历位置+1</p><p>主字符串从第三位开始 取出o  子字符串取出第一位 g  不匹配        主字符串遍历位置+1</p><p>主字符串从第四位开始 取出d  子字符串取出第一位 g  不匹配        主字符串遍历位置+1</p><p>主字符串从第五位开始 取出g  子字符串取出第一位 g  匹配  进入子循环<br> 取出o              取出o                  匹配<br> 取出o              取出o                  匹配<br> 取出g              取出g                  匹配<br> 取出l              取出l                  匹配<br> 取出e              取出e                  匹配   子循环结束    匹配成功</p><p>假设主字符串 长度为  n   子字符串长度为m   n&gt;&#x3D; m<br> 最好的情况需要匹配m次   时间复杂度为 0(m)</p><p>例如  000000000001  匹配   00001 每次进入子循环之后 都要遍历到最后一次子循环才得出不匹配<br> 需要匹配次数   (n-m+1) * m<br> 最坏的情况需要匹配m次   时间复杂度为 0((n-m+1) * m)</p><p>下面为动画演示效果</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E6%9C%B4%E7%B4%A0%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/1.gif" alt="img"></p><p>通过数组下表实现朴素匹配算法</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E6%9C%B4%E7%B4%A0%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/2.gif" alt="img"></p><ul><li>若当前⼦串匹配失败，则主串指针 i 指向下⼀个⼦串的第⼀个位置，模式串指针 j 回到模式串的第⼀个位置</li><li>若 <code>j &gt; T.length</code>，则当前⼦串匹配成功，返回当前⼦串第⼀个字符的位置 —— <code>i - T.length</code></li></ul><p>引用：</p><blockquote><p>1.<a href="https://www.jianshu.com/p/602fae829843">算法基础 - 朴素模式匹配算法、KMP模式匹配算法</a></p></blockquote><blockquote><p>2.<a href="http://t.csdn.cn/e4Ktp">朴素模式匹配算法（C语言）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 朴素匹配算法 </tag>
            
            <tag> BruteForce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-KMP算法</title>
      <link href="/2023/04/16/cha-zhao-suan-fa-kmp-suan-fa/"/>
      <url>/2023/04/16/cha-zhao-suan-fa-kmp-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-KMP算法"><a href="#3-1-KMP算法" class="headerlink" title="3.1 KMP算法"></a>3.1 KMP算法</h2><h3 id="3-1-1-简介"><a href="#3-1-1-简介" class="headerlink" title="3.1.1 简介"></a>3.1.1 简介</h3><p>KMP算法是一种改进的$\color{orange} {字符串匹配算法}$。KMP算法是三位学者在 Brute-Force算法的基础上同时提出的模式匹配的改进算法。Brute- Force算法在模式串中有多个字符和主串中的若干个连续字符比较都相等,但最后一个字符比较不相等时,主串的比较位置需要回退。KMP算法在上述情况下,主串位置不需要回退,从而可以大大提高效率。</p><h3 id="3-1-2-KMP算法解决的问题模型"><a href="#3-1-2-KMP算法解决的问题模型" class="headerlink" title="3.1.2 KMP算法解决的问题模型"></a>3.1.2 KMP算法解决的问题模型</h3><p>KMP算法算是朴素匹配算法的优化版本，在从主串中寻找子串的时候遇到主串字符数特别大，此时使用朴素匹配算法的时间复杂度就很高，但空间复杂度很低。而使用KMP算法就可以降低时间复杂度</p><h3 id="3-1-3-介绍"><a href="#3-1-3-介绍" class="headerlink" title="3.1.3 介绍"></a>3.1.3 介绍</h3><h4 id="1-最长公共前缀和后缀"><a href="#1-最长公共前缀和后缀" class="headerlink" title="1.最长公共前缀和后缀"></a>1.最长公共前缀和后缀</h4><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/1.png" alt="img"></p><p>如上图举例：</p><blockquote><p>比如一个字符串：<code>abbccdabb</code><br>它的前缀集合为：<code>a、ab、abb、abbc、abbcc、abbccd、abbccda、abbccdab</code><br>它的后缀集合为：<code>b、bb、abb、dabb、cdabb、ccdabb、bccdabb、bbccdabb</code><br>可以看出来，最长的前缀和后缀相等的不就是<code>abb</code>吗。<br>所以$\color{orange} {最长公共前缀和后缀}$就是<code>abb</code></p></blockquote><h4 id="2-图解KMP"><a href="#2-图解KMP" class="headerlink" title="2.图解KMP"></a>2.图解KMP</h4><p>第一个长条代表主串，第二个长条代表子串。红色部分代表两串中已匹配的部分，绿色和蓝色部分分别代表主串和子串中不匹配的字符。</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/2.png" alt="img"></p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/3.png" alt="img"></p><p>现在发现了不匹配的地方，根据KMP算法，我们要将字串向后移动，现在要确定移动多少的问题。<br>这个时候之前提到的最长相等前后缀就派上用场了。</p><p>可以看到原来红色部分的最长相等前缀和后缀是ab，所以字串移动的距离就是ab两个字符串的长度，移动距离为2。<br>移动完成的效果如图所示：</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/4.png" alt="img"></p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/5.png" alt="img"></p><p>这一步弄懂了，KMP算法的精髓基本就掌握差不多了。<br>接下来的就是一个循环的过程，我们之前所说的，每一个字符前的字符串都有最长相等前后缀，而且最长相等前后缀的长度是我们移位的关键，所以我们单独用一个next数组存储子串的最长相等前后缀的长度。而且next数组的数值只与子串本身有关。<br>所以next[i]&#x3D;j,含义是：下标为i 的字符前的字符串最长相等前后缀的长度为j。<br>所以我们可以算出来next数组的具体的数值，如下表所示：</p><table><thead><tr><th><strong>next[0]</strong></th><th><strong>next[1]</strong></th><th><strong>next[2]</strong></th><th><strong>next3]</strong></th><th><strong>next[4]</strong></th><th><strong>next[5]</strong></th><th><strong>next[6]</strong></th><th><strong>next[7]</strong></th></tr></thead><tbody><tr><td>-1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>0</td></tr></tbody></table><p>我们把子串移动，也就是让s[5]与t[5]前面字符串的最长相等前缀后一个字符再比较，而该字符的位置就是t[？],很明显这里的？是2，就是不匹配的字符前的字符串 最长相等前后缀的长度。</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/6.png" alt="img"></p><p>也是不匹配的字符处的next数组next[5]应该保存的值，也是子串回溯后应该对应的字符的下标。 所以？&#x3D;next[5]&#x3D;2。接下来就是比对是s[5]和t[next[5]]的字符。这里也是最奇妙的地方，也是为什么KMP算法的代码可以那么简洁优雅的关键。</p><p>next数组作用有两个：</p><ol><li>next[i]的值表示下标为i的字符前的字符串最长相等前后缀的长度。</li><li>表示该处字符不匹配时应该回溯到的字符的下标.</li></ol><h3 id="3-1-4-代码"><a href="#3-1-4-代码" class="headerlink" title="3.1.4 代码"></a>3.1.4 代码</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int KMPIndex(SqString s,SqString t)  &#x2F;&#x2F;KMP算法&#123;int next[MaxSize],i&#x3D;0,j&#x3D;0;GetNext(t,next);while (i&lt;s.length &amp;&amp; j&lt;t.length) &#123;if (j&#x3D;&#x3D;-1 || s.data[i]&#x3D;&#x3D;t.data[j]) &#123;i++;j++;  &#x2F;&#x2F;i,j各增1&#125;else j&#x3D;next[j]; &#x2F;&#x2F;i不变,j后退，现在知道为什么这样让子串回退了吧    &#125;    if (j&gt;&#x3D;t.length)return(i-t.length);  &#x2F;&#x2F;返回匹配模式串的首字符下标    else  return(-1);        &#x2F;&#x2F;返回不匹配标志&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用：</p><blockquote><p>1.<a href="http://t.csdn.cn/zFlHG">KMP算法的详细讲解。（适用于所有的字串查找问题。）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-概述</title>
      <link href="/2023/04/16/cha-zhao-suan-fa-gai-shu/"/>
      <url>/2023/04/16/cha-zhao-suan-fa-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h1 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h1><p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。</p><h1 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h1><ol><li><p>静态查找和动态查找</p><ul><li>静态查找和动态查找都是针对查找表而言的，动态表指查找表中有删除和插入操作的表。</li></ul></li><li><p>无序查找和有序查找</p><ul><li>无序查找：被查找数列有序无序均可</li><li>有序查找：被查找数列必须为有序数列</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML第一章-2</title>
      <link href="/2023/04/14/html-di-yi-zhang-2/"/>
      <url>/2023/04/14/html-di-yi-zhang-2/</url>
      
        <content type="html"><![CDATA[<p>着重来说明一下标准元数据</p><ol><li><p>Keywords (关键字)<br> 说明：告诉搜索引擎你网页的关键字是什么。<br> 用法：<Meta name="Keywords" Content="网络营销，网站推广，网站建设，搜索引擎优化"></p></li><li><p>Description (网页描述)<br> 说明：Description用来告诉搜索引擎你的网页主要内容。<br> 用法：<meta name="description" content="网站开发、网站优化、网站推广和网络营销交流学习中心" /></p></li><li><p>Robots (机器人向导)<br> 说明：Robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。Content的参数有all、none、index、noindex、follow、nofollow。默认是all。<br> 用法：<Meta name="Robots" Content="All|None|Index|Noindex|Follow|Nofollow"><br> all：文件将被检索，且页面上的链接可以被查询；<br> none：文件将不被检索，且页面上的链接不可以被查询；(和 “noindex, no follow” 起相同作用)<br> index：文件将被检索；（让robot&#x2F;spider登录）<br> follow：页面上的链接可以被查询；<br> noindex：文件将不被检索，但页面上的链接可以被查询；(不让robot&#x2F;spider登录)<br> nofollow：文件将不被检索，页面上的链接可以被查询。(不让robot&#x2F;spider顺着此页的连接往下探找) </p></li><li><p>Author (作者)<br> 说明：标注网页的作者或制作组<br> 　　用法：<Meta name="Author" Content="豆苗，doumiao@live.cn"><br> 　　注意：Content可以是：你或你的制作组的名字,或Email</p></li><li><p>Copyright (版权)<br> 说明：标注版权<br> 　　用法：<Meta name="Copyright" Content="本页版权归豆苗网所有"></p></li><li><p>Generator (编辑器)<br> 说明：编辑器的说明<br> 　　用法：<Meta name="Generator" Content="PCDATA|FrontPage|"><br> 　　注意：Content&#x3D;”你所用编辑器”</p></li><li><p>revisit-after (重访)</p></li><li><p>HTML规范中定义的标准名称application-name 网页中所运行的应用名称。（注意不同于<title>标签）<br> author： 文档作者的名字<br> description：对页面内容的描述，一些浏览器将其作为书签的默认描述。<br> generator： 生成此页面的软件的标识符<br> keywords： 与页面内容相关的关键词，使用逗号分割。<br> referrer： 控制由当前文档发出的请求的HTTP Referer请求头<br> referrer的可选值<br> no-referrer： 不发送HTTP Referer请求头<br> origin： 只发送当前文档的origin<br> no-referrer-when-downgrade:<br> 如果请求目标比当前页面一样安全或更加安全，则发送完整URL<br> 如果目标页面比当前页面更加不安全，则不发送referrer【这是默认行为】<br> origin-when-cross-origin：对同源请求发送完整URL（不含参数），其他情况只发送origin<br> same-origin： 对同源请求发送完整URL（不含参数），其他情况，不发送referrer请求头<br> strict-origin：<br> 如果请求目标与当前页面一样或更加安全，发送 origin<br> 如果请求目标不如当前页面安全，不发送referrer<br> strict-origin-when-cross-origin：对同源请求发送完整URL（不含参数）<br> 其他情况<br> 如果请求目标与当前页面一样或更加安全，发送origin<br> 如果请求目标不如当前页面安全，则不发送referrer<br> unsafe-URL：对同源请求和跨源请求发送完整URL（不含参数）</p></li><li><p>CSS颜色调整规范中定义的标准名称<br> color-scheme ： 指定与当前文档兼容的配色方案，它的可选值有：<br> normal：未指定配色方案，应当仅使用默认配色方案进行渲染<br> [light | dark]+：文档支持的一种或多种配色方案，优先第一种。<br> only light：仅支持浅色模式（浅色背景，深色前景）</p></li><li><p>CSS设备适配规范定义的标准名称<br>viewport<br>viewport：为视口的初始大小提供指示，目前仅用于移动设备，其可选的值有：<br>width：定义视口的宽度，可能的值：<br>一个正整数。（此时单位为像素）<br>一个字符串。（带单位的CSS宽度值）<br>device-width 表示与设备宽度一致<br>height： 定义viewport的高度，未被任浏览器使用，不介绍值了<br>initial-scale：定义设备宽度（与横竖屏相关）与视口大小之间的比例<br>是一个0.0-10.0之间的【正数】；<br>maximum-scale： 定义缩放的最大值，必须大于等于minimum-scale<br>是一个0.0-10.0之间的【正数】；<br>minimum-scale：定义缩放的最小值，必须小于等于maximum-scale<br>是一个0.0-10.0之间的【正数】；<br>user-scalable：用户是否可以缩放当前页面<br>yes 或 no ，默认为yes<br>viewport-fit ： 视口是否根据设备自适应，可能的值<br>auto：不会影响“初始布局”视口，整个网页都是可查看的<br>caontain：视口被缩放以适合显示中内接的最大矩形<br>cover： 缩放视口以填充设备显示。<br>将 user-scalable 设置为 no 会阻止一切意义上的缩放，视力不好的人可能会因此无法阅读和理解页面内容</p></li><li><p>其它元数据名称<br>creator：当前文档的创建者，例如某个组织或者机构。如果有不止一个创建者，则应当使用多个名称为 creator 的 <meta> 元素<br>googolbot：robots 的替代名称，只被 Googlebot（Google 的网页爬虫&#x2F;索引搜寻器）使用<br>publisher：当前文档的发布者&#x2F;出版者<br>robots：爬虫应当遵守的规则。是一个使用逗号分隔的、由下列值构成的列表：<br>index：允许爬虫索引此页面（所有爬虫）<br>noindex：要求爬虫不索引此页面（所有爬虫）<br>follow ：允许爬虫跟踪页面上链接所指向的页面（所有爬虫）<br>onfollow：要求爬虫不跟踪页面上的链接（所有爬虫）<br>all：与index,follow 等价（只针对谷歌爬虫）<br>none：与noindex, nofollow等价（只针对谷歌爬虫）<br>noarchive：要求搜索引擎不缓存页面内容（针对谷歌、雅虎、必应搜索）<br>nosnippet：要求搜索引擎不要在搜索结果页显示本页面的描述。（针对谷歌、必应搜索）<br>noimageindex：要求本页面不会成为搜索结果页中索引图像的引用页。（只针对谷歌搜索）<br>nocache：noarchive的替代名称。（只针对必应）</p></li></ol><h5 id="3-http-equiv属性，content属性"><a href="#3-http-equiv属性，content属性" class="headerlink" title="3.http-equiv属性，content属性"></a>3.http-equiv属性，content属性</h5><p>http-equiv 属性用来覆盖 HTTP 回应的头信息字段，content 属性是该字段的内容。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Content-Security-Policy<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>default-src 'self'<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面代码可以覆盖 HTTP 回应的 Content-Security-Policy 字段。</p><h4 id="lt-title-gt-标签"><a href="#lt-title-gt-标签" class="headerlink" title="&lt;title&gt; 标签"></a><code>&lt;title&gt;</code> 标签</h4><p>此标签用于指定页面的标题，会显示在浏览器窗口的标题栏</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>网页标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>搜索引擎根据它排序</p><p>这个标签的内部不能放置其他标签，只能放置无格式的纯文本</p><h4 id="lt-body-gt-标签"><a href="#lt-body-gt-标签" class="headerlink" title="&lt;body&gt; 标签"></a><code>&lt;body&gt;</code> 标签</h4><p><code>&lt;body&gt;</code> 标签是一个容器标签，用于放置网页的主体内容。浏览器显示的页面内容，都是放置在它的内部。它是<code>&lt;html&gt;</code> 的第二个子元素，紧跟在<code>&lt;head&gt;</code> 后面</p><h2 id="1-4空格和换行"><a href="#1-4空格和换行" class="headerlink" title="1.4空格和换行"></a>1.4空格和换行</h2><p>heml里的多个空格和换行最后只会被合并为一个</p><h2 id="1-5注释"><a href="#1-5注释" class="headerlink" title="1.5注释"></a>1.5注释</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 这是一个注释 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者是</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--&lt;p>HelloWorld!&lt;/p>--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML第一章-1</title>
      <link href="/2023/04/14/html-di-yi-zhang-1/"/>
      <url>/2023/04/14/html-di-yi-zhang-1/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h1 id="1-HTML简介"><a href="#1-HTML简介" class="headerlink" title="1.HTML简介"></a>1.HTML简介</h1><h2 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h2><p>浏览器的网页开发涉及3种技术：HTML、CSS、JavaScript</p><ul><li>HTML：定义网页的结构和内容</li><li>CSS：定义网页的样式</li><li>JavaScript：定义网页与用户的互动行为</li></ul><p>基础网页的HTML源码</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;    &lt;title&gt;网页标题&lt;&#x2F;title&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;    &lt;p&gt;Hello World&lt;&#x2F;p&gt;  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2网页的基本概念"><a href="#1-2网页的基本概念" class="headerlink" title="1.2网页的基本概念"></a>1.2网页的基本概念</h2><h3 id="1-2-1标签"><a href="#1-2-1标签" class="headerlink" title="1.2.1标签"></a>1.2.1标签</h3><p>HTML代码由许多的不同标签（tag）组成</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>网页标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>        HelloWorld!    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的就是一些标签，有的标签是成对出现的，例如<code>&lt;title&gt;&lt;/title&gt;</code> <code>&lt;div&gt;&lt;/div&gt;</code>，但有的只出现一个例如说<code>&lt;meta = ……&gt;</code> 因为这只需要一个标签就可以完成功能。</p><p><strong>值得一提的是，在html中可以将代码写到一行里，且对大小写不敏感</strong></p><p>所以有时候在发布网页之前开发者会把源码压缩成一行，以减少传输的字节数。网页内容的缩进和换行主要靠<code>CSS</code> 样式来实现</p><h3 id="1-2-2元素"><a href="#1-2-2元素" class="headerlink" title="1.2.2元素"></a>1.2.2元素</h3><p>浏览器渲染网页的时候，会把html源码解析成一个标签树，每个标签都是一个节点（node），成为网页元素（element）。</p><p>所以标签和元素基本上是同义词，只是使用的场合不一样，标签是源码角度来看，元素是编程角度来看，例如<code>&lt;p&gt;</code> 标签对应网页的<code>p</code>元素。</p><p>而嵌套的标签就构成了网页元素的层级关系</p><p>元素分类:</p><ul><li><p>块级元素（block）</p></li><li><p>行内元素（inline）</p><p>  其中块级元素默认占据一个独立的区域，在网页上会自动另起一行，占据100%的宽度</p></li></ul><h3 id="1-2-3属性"><a href="#1-2-3属性" class="headerlink" title="1.2.3属性"></a>1.2.3属性</h3><p>属性（attribute）是<code>标签</code> 的额外信息，使用空格与标签名和其他属性分隔</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>demo.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>&lt;img&gt;</code> 标签有两个属性：src、width</p><h2 id="1-3网页的基本标签"><a href="#1-3网页的基本标签" class="headerlink" title="1.3网页的基本标签"></a>1.3网页的基本标签</h2><p>主要标签：<code>&lt;!doctype&gt;</code> 此标签标示文档类类型，告诉浏览器如何解析万个亿</p><p>常用**<!DOCTYPE html>**</p><h4 id="lt-html-gt-标签"><a href="#lt-html-gt-标签" class="headerlink" title="&lt;html&gt;标签"></a><code>&lt;html&gt;</code>标签</h4><p><code>&lt;html&gt;</code> 标签是网页的顶层容器，也称为根元素（root element），其他元素都是它的子元素。一个网页只能有一个<code>&lt;html&gt;</code> 标签</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述代码表示网页内容默认为英语</p><h4 id="lt-head-gt-标签"><a href="#lt-head-gt-标签" class="headerlink" title="&lt;head&gt; 标签"></a><code>&lt;head&gt;</code> 标签</h4><head>标签是一个容器标签用于放置网页的元信息。它的内容不会出现在网页上，而是为网页渲染做准备<p>head是<html>的第一个子元素，如何网页不包含<head>，浏览器会自动创建一个</p><p>head的子元素一般有七个</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td><code>&lt;meta&gt;</code></td><td>设置网页的元数据</td></tr><tr><td><code>&lt;link&gt;</code></td><td>链接外部样式表</td></tr><tr><td><code>&lt;title&gt;</code></td><td>设置网页标题</td></tr><tr><td><code>&lt;style&gt;</code></td><td>放置内嵌的样式表</td></tr><tr><td><code>&lt;script&gt;</code></td><td>引入脚本</td></tr><tr><td><code>&lt;noscript&gt;</code></td><td>浏览器不支持脚本时，所要显示的内容</td></tr><tr><td><code>&lt;base&gt;</code></td><td>设置网页内部相对URL的计算基准</td></tr></tbody></table><h4 id="lt-meta-gt-标签"><a href="#lt-meta-gt-标签" class="headerlink" title="&lt;meta&gt; 标签"></a><code>&lt;meta&gt;</code> 标签</h4><p>此标签用于设置或说明网页的元数据 ，必须放到<code>&lt;head&gt;</code> 里面，一个<code>&lt;meta&gt;</code> 标签就是一项元数据，网页可以有多个<code>&lt;meta&gt;</code></p><p>一般来说网页应该有两个meta标签，放到head标签最前面</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-charset属性"><a href="#1-charset属性" class="headerlink" title="1.charset属性"></a>1.charset属性</h5><p>charset属性用于指定网页的编码方式</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述代码声明网页为utf-8编码，虽然可以使用其他编码方式，但主要应该使用utf-8编码、</p><h5 id="2-name属性，content属性"><a href="#2-name属性，content属性" class="headerlink" title="2.name属性，content属性"></a>2.name属性，content属性</h5><p>name属性表示元数据的名字，content属性表示元数据的值</p><p>例如</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>description<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTML 语言入门<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>keywords<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTML,教程<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>author<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>张三<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码包含了三个元数据：</p><ul><li>description：网页内容的描述</li><li>keywords：网页内容的关键字</li><li>auther：网页作者</li></ul><p>meta标签是一个辅助性的标签，在网页上<strong>不可见</strong></p><p>name标签是描述网页的，以便于搜索机器人（搜索引擎）进行查找、分类，目前几乎所有的搜索引擎都使用网上机器人自动查找meta值来给网页分类</p><p>这里要详细讲一下，name属性分类两种</p><ul><li>标准元数据</li><li>用户自定义内容</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主页</title>
      <link href="/2023/04/10/zhu-ye/"/>
      <url>/2023/04/10/zhu-ye/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/10/hello-world/"/>
      <url>/2023/04/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
