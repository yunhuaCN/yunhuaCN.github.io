<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>查找算法-二分查找算法</title>
      <link href="/2023/04/16/cha-zhao-suan-fa-er-fen-cha-zhao-suan-fa/"/>
      <url>/2023/04/16/cha-zhao-suan-fa-er-fen-cha-zhao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="3-4-折半查找（二分查找法）"><a href="#3-4-折半查找（二分查找法）" class="headerlink" title="3.4 折半查找（二分查找法）"></a>3.4 折半查找（二分查找法）</h2><h3 id="3-4-1-简介"><a href="#3-4-1-简介" class="headerlink" title="3.4.1 简介"></a>3.4.1 简介</h3><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fromModule=lemma_inlink">线性表</a>必须采用<a href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/1347176?fromModule=lemma_inlink">顺序存储结构</a>，而且表中元素按关键字有序排列。</p><h3 id="3-4-2-查找过程"><a href="#3-4-2-查找过程" class="headerlink" title="3.4.2 查找过程"></a>3.4.2 查找过程</h3><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><p>详解原理：</p><blockquote><ol><li>设置查找区间：low &#x3D; 0；high&#x3D; n；</li><li>若查找区间[low, high]不存在，则查找失败；否则转步骤3</li><li>取中间位mid &#x3D; (low + high) &#x2F; 2；比较 target 与 arr[mid]，有以下三种情况：<br>         3.1 若 target &lt; arr[mid]，则high &#x3D; mid - 1；查找在左半区间进行，转步骤2；<br>         3.2 若 target &gt; arr[mid]，则low &#x3D; mid + 1；查找在右半区间进行，转步骤2；<br>         3.3 若 target &#x3D; arr[mid]，则查找成功，返回 mid 值；</li></ol></blockquote><h3 id="3-4-3-算法要求"><a href="#3-4-3-算法要求" class="headerlink" title="3.4.3 算法要求"></a>3.4.3 算法要求</h3><p>1.必须采用顺序存储结构</p><p>2.必须按关键字大小有序排列</p><h3 id="3-4-4-二分查找动画演示"><a href="#3-4-4-二分查找动画演示" class="headerlink" title="3.4.4 二分查找动画演示"></a>3.4.4 二分查找动画演示</h3><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/1.gif" alt="img"></p><p>可以看出 二分查找 在查找数字 <code>37</code> 时只需3次，而 顺序查找 在查找<code>37</code>时需要12次。 </p><p>二分查找<strong>最好时间复杂度</strong>是<img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/2.gif" alt="img"></p><p>二分查找<strong>最坏时间复杂度</strong>是<img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/3.gif" alt="img"></p><p>引用：</p><blockquote><p>1.<a href="http://t.csdn.cn/lUyaF">查找算法：二分查找</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> BinarySearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-顺序查找算法</title>
      <link href="/2023/04/16/cha-zhao-suan-fa-shun-xu-cha-zhao-suan-fa/"/>
      <url>/2023/04/16/cha-zhao-suan-fa-shun-xu-cha-zhao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="3-3-顺序查找"><a href="#3-3-顺序查找" class="headerlink" title="3.3 顺序查找"></a>3.3 顺序查找</h2><p>顺序查找算法又称顺序搜索算法或者线性搜索算法，，是所有查找算法中最基本、最简单的，对应的时间复杂度为O(n)。</p><p>此算法用于在一系列数中寻找一个数或者一串字符串中寻找一个字符。</p><p>顺序查找算法就是用第一个元素开始逐个与目标元素对比。</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/1.gif" alt="img"></p><p>引用：</p><blockquote><p>1.<a href="http://t.csdn.cn/D29X9">顺序查找算法</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 顺序查找算法 </tag>
            
            <tag> SeqSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-朴素匹配算法</title>
      <link href="/2023/04/16/cha-zhao-suan-fa-po-su-pi-pei-suan-fa/"/>
      <url>/2023/04/16/cha-zhao-suan-fa-po-su-pi-pei-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="3-2-朴素匹配算法"><a href="#3-2-朴素匹配算法" class="headerlink" title="3.2 朴素匹配算法"></a>3.2 朴素匹配算法</h2><p>朴素匹配算法又称暴力匹配算法</p><p>假设我们要从 主字符串goodgoogle 中匹配  子字符串google<br> 朴素模式匹配算法就是 通过从主字符的头部开始 一次循环匹配的字符串的挨个字符   如果不通过  则主字符串头部位置遍历位置+1  在依次遍历子字符串的字符</p><p>匹配过程<br> 主字符串从第一位开始 取出g   子字符串取出第一位 g  匹配     进入子循环<br> 取出o              取出o                  匹配<br> 取出o              取出o                  匹配<br> 取出d              取出g                  不匹配    主字符串遍历位置+1</p><p>主字符串从第二位开始 取出o  子字符串取出第一位 g  不匹配        主字符串遍历位置+1</p><p>主字符串从第三位开始 取出o  子字符串取出第一位 g  不匹配        主字符串遍历位置+1</p><p>主字符串从第四位开始 取出d  子字符串取出第一位 g  不匹配        主字符串遍历位置+1</p><p>主字符串从第五位开始 取出g  子字符串取出第一位 g  匹配  进入子循环<br> 取出o              取出o                  匹配<br> 取出o              取出o                  匹配<br> 取出g              取出g                  匹配<br> 取出l              取出l                  匹配<br> 取出e              取出e                  匹配   子循环结束    匹配成功</p><p>假设主字符串 长度为  n   子字符串长度为m   n&gt;&#x3D; m<br> 最好的情况需要匹配m次   时间复杂度为 0(m)</p><p>例如  000000000001  匹配   00001 每次进入子循环之后 都要遍历到最后一次子循环才得出不匹配<br> 需要匹配次数   (n-m+1) * m<br> 最坏的情况需要匹配m次   时间复杂度为 0((n-m+1) * m)</p><p>下面为动画演示效果</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E6%9C%B4%E7%B4%A0%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/1.gif" alt="img"></p><p>通过数组下表实现朴素匹配算法</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E6%9C%B4%E7%B4%A0%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/2.gif" alt="img"></p><ul><li>若当前⼦串匹配失败，则主串指针 i 指向下⼀个⼦串的第⼀个位置，模式串指针 j 回到模式串的第⼀个位置</li><li>若 <code>j &gt; T.length</code>，则当前⼦串匹配成功，返回当前⼦串第⼀个字符的位置 —— <code>i - T.length</code></li></ul><p>引用：</p><blockquote><p>1.<a href="https://www.jianshu.com/p/602fae829843">算法基础 - 朴素模式匹配算法、KMP模式匹配算法</a></p></blockquote><blockquote><p>2.<a href="http://t.csdn.cn/e4Ktp">朴素模式匹配算法（C语言）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> 朴素匹配算法 </tag>
            
            <tag> BruteForce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-KMP算法</title>
      <link href="/2023/04/16/cha-zhao-suan-fa-kmp-suan-fa/"/>
      <url>/2023/04/16/cha-zhao-suan-fa-kmp-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-KMP算法"><a href="#3-1-KMP算法" class="headerlink" title="3.1 KMP算法"></a>3.1 KMP算法</h2><h3 id="3-1-1-简介"><a href="#3-1-1-简介" class="headerlink" title="3.1.1 简介"></a>3.1.1 简介</h3><p>KMP算法是一种改进的$\color{orange} {字符串匹配算法}$。KMP算法是三位学者在 Brute-Force算法的基础上同时提出的模式匹配的改进算法。Brute- Force算法在模式串中有多个字符和主串中的若干个连续字符比较都相等,但最后一个字符比较不相等时,主串的比较位置需要回退。KMP算法在上述情况下,主串位置不需要回退,从而可以大大提高效率。</p><h3 id="3-1-2-KMP算法解决的问题模型"><a href="#3-1-2-KMP算法解决的问题模型" class="headerlink" title="3.1.2 KMP算法解决的问题模型"></a>3.1.2 KMP算法解决的问题模型</h3><p>KMP算法算是朴素匹配算法的优化版本，在从主串中寻找子串的时候遇到主串字符数特别大，此时使用朴素匹配算法的时间复杂度就很高，但空间复杂度很低。而使用KMP算法就可以降低时间复杂度</p><h3 id="3-1-3-介绍"><a href="#3-1-3-介绍" class="headerlink" title="3.1.3 介绍"></a>3.1.3 介绍</h3><h4 id="1-最长公共前缀和后缀"><a href="#1-最长公共前缀和后缀" class="headerlink" title="1.最长公共前缀和后缀"></a>1.最长公共前缀和后缀</h4><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/1.png" alt="img"></p><p>如上图举例：</p><blockquote><p>比如一个字符串：<code>abbccdabb</code><br>它的前缀集合为：<code>a、ab、abb、abbc、abbcc、abbccd、abbccda、abbccdab</code><br>它的后缀集合为：<code>b、bb、abb、dabb、cdabb、ccdabb、bccdabb、bbccdabb</code><br>可以看出来，最长的前缀和后缀相等的不就是<code>abb</code>吗。<br>所以$\color{orange} {最长公共前缀和后缀}$就是<code>abb</code></p></blockquote><h4 id="2-图解KMP"><a href="#2-图解KMP" class="headerlink" title="2.图解KMP"></a>2.图解KMP</h4><p>第一个长条代表主串，第二个长条代表子串。红色部分代表两串中已匹配的部分，绿色和蓝色部分分别代表主串和子串中不匹配的字符。</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/2.png" alt="img"></p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/3.png" alt="img"></p><p>现在发现了不匹配的地方，根据KMP算法，我们要将字串向后移动，现在要确定移动多少的问题。<br>这个时候之前提到的最长相等前后缀就派上用场了。</p><p>可以看到原来红色部分的最长相等前缀和后缀是ab，所以字串移动的距离就是ab两个字符串的长度，移动距离为2。<br>移动完成的效果如图所示：</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/4.png" alt="img"></p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/5.png" alt="img"></p><p>这一步弄懂了，KMP算法的精髓基本就掌握差不多了。<br>接下来的就是一个循环的过程，我们之前所说的，每一个字符前的字符串都有最长相等前后缀，而且最长相等前后缀的长度是我们移位的关键，所以我们单独用一个next数组存储子串的最长相等前后缀的长度。而且next数组的数值只与子串本身有关。<br>所以next[i]&#x3D;j,含义是：下标为i 的字符前的字符串最长相等前后缀的长度为j。<br>所以我们可以算出来next数组的具体的数值，如下表所示：</p><table><thead><tr><th><strong>next[0]</strong></th><th><strong>next[1]</strong></th><th><strong>next[2]</strong></th><th><strong>next3]</strong></th><th><strong>next[4]</strong></th><th><strong>next[5]</strong></th><th><strong>next[6]</strong></th><th><strong>next[7]</strong></th></tr></thead><tbody><tr><td>-1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>0</td></tr></tbody></table><p>我们把子串移动，也就是让s[5]与t[5]前面字符串的最长相等前缀后一个字符再比较，而该字符的位置就是t[？],很明显这里的？是2，就是不匹配的字符前的字符串 最长相等前后缀的长度。</p><p><img src="/../Markdown_images/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/6.png" alt="img"></p><p>也是不匹配的字符处的next数组next[5]应该保存的值，也是子串回溯后应该对应的字符的下标。 所以？&#x3D;next[5]&#x3D;2。接下来就是比对是s[5]和t[next[5]]的字符。这里也是最奇妙的地方，也是为什么KMP算法的代码可以那么简洁优雅的关键。</p><p>next数组作用有两个：</p><ol><li>next[i]的值表示下标为i的字符前的字符串最长相等前后缀的长度。</li><li>表示该处字符不匹配时应该回溯到的字符的下标.</li></ol><h3 id="3-1-4-代码"><a href="#3-1-4-代码" class="headerlink" title="3.1.4 代码"></a>3.1.4 代码</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int KMPIndex(SqString s,SqString t)  &#x2F;&#x2F;KMP算法&#123;int next[MaxSize],i&#x3D;0,j&#x3D;0;GetNext(t,next);while (i&lt;s.length &amp;&amp; j&lt;t.length) &#123;if (j&#x3D;&#x3D;-1 || s.data[i]&#x3D;&#x3D;t.data[j]) &#123;i++;j++;  &#x2F;&#x2F;i,j各增1&#125;else j&#x3D;next[j]; &#x2F;&#x2F;i不变,j后退，现在知道为什么这样让子串回退了吧    &#125;    if (j&gt;&#x3D;t.length)return(i-t.length);  &#x2F;&#x2F;返回匹配模式串的首字符下标    else  return(-1);        &#x2F;&#x2F;返回不匹配标志&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用：</p><blockquote><p>1.<a href="http://t.csdn.cn/zFlHG">KMP算法的详细讲解。（适用于所有的字串查找问题。）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-概述</title>
      <link href="/2023/04/16/cha-zhao-suan-fa-gai-shu/"/>
      <url>/2023/04/16/cha-zhao-suan-fa-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h1 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h1><p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。</p><h1 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h1><ol><li><p>静态查找和动态查找</p><ul><li>静态查找和动态查找都是针对查找表而言的，动态表指查找表中有删除和插入操作的表。</li></ul></li><li><p>无序查找和有序查找</p><ul><li>无序查找：被查找数列有序无序均可</li><li>有序查找：被查找数列必须为有序数列</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML第一章-2</title>
      <link href="/2023/04/14/html-di-yi-zhang-2/"/>
      <url>/2023/04/14/html-di-yi-zhang-2/</url>
      
        <content type="html"><![CDATA[<p>着重来说明一下标准元数据</p><ol><li><p>Keywords (关键字)<br> 说明：告诉搜索引擎你网页的关键字是什么。<br> 用法：<Meta name="Keywords" Content="网络营销，网站推广，网站建设，搜索引擎优化"></p></li><li><p>Description (网页描述)<br> 说明：Description用来告诉搜索引擎你的网页主要内容。<br> 用法：<meta name="description" content="网站开发、网站优化、网站推广和网络营销交流学习中心" /></p></li><li><p>Robots (机器人向导)<br> 说明：Robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。Content的参数有all、none、index、noindex、follow、nofollow。默认是all。<br> 用法：<Meta name="Robots" Content="All|None|Index|Noindex|Follow|Nofollow"><br> all：文件将被检索，且页面上的链接可以被查询；<br> none：文件将不被检索，且页面上的链接不可以被查询；(和 “noindex, no follow” 起相同作用)<br> index：文件将被检索；（让robot&#x2F;spider登录）<br> follow：页面上的链接可以被查询；<br> noindex：文件将不被检索，但页面上的链接可以被查询；(不让robot&#x2F;spider登录)<br> nofollow：文件将不被检索，页面上的链接可以被查询。(不让robot&#x2F;spider顺着此页的连接往下探找) </p></li><li><p>Author (作者)<br> 说明：标注网页的作者或制作组<br> 　　用法：<Meta name="Author" Content="豆苗，doumiao@live.cn"><br> 　　注意：Content可以是：你或你的制作组的名字,或Email</p></li><li><p>Copyright (版权)<br> 说明：标注版权<br> 　　用法：<Meta name="Copyright" Content="本页版权归豆苗网所有"></p></li><li><p>Generator (编辑器)<br> 说明：编辑器的说明<br> 　　用法：<Meta name="Generator" Content="PCDATA|FrontPage|"><br> 　　注意：Content&#x3D;”你所用编辑器”</p></li><li><p>revisit-after (重访)</p></li><li><p>HTML规范中定义的标准名称application-name 网页中所运行的应用名称。（注意不同于<title>标签）<br> author： 文档作者的名字<br> description：对页面内容的描述，一些浏览器将其作为书签的默认描述。<br> generator： 生成此页面的软件的标识符<br> keywords： 与页面内容相关的关键词，使用逗号分割。<br> referrer： 控制由当前文档发出的请求的HTTP Referer请求头<br> referrer的可选值<br> no-referrer： 不发送HTTP Referer请求头<br> origin： 只发送当前文档的origin<br> no-referrer-when-downgrade:<br> 如果请求目标比当前页面一样安全或更加安全，则发送完整URL<br> 如果目标页面比当前页面更加不安全，则不发送referrer【这是默认行为】<br> origin-when-cross-origin：对同源请求发送完整URL（不含参数），其他情况只发送origin<br> same-origin： 对同源请求发送完整URL（不含参数），其他情况，不发送referrer请求头<br> strict-origin：<br> 如果请求目标与当前页面一样或更加安全，发送 origin<br> 如果请求目标不如当前页面安全，不发送referrer<br> strict-origin-when-cross-origin：对同源请求发送完整URL（不含参数）<br> 其他情况<br> 如果请求目标与当前页面一样或更加安全，发送origin<br> 如果请求目标不如当前页面安全，则不发送referrer<br> unsafe-URL：对同源请求和跨源请求发送完整URL（不含参数）</p></li><li><p>CSS颜色调整规范中定义的标准名称<br> color-scheme ： 指定与当前文档兼容的配色方案，它的可选值有：<br> normal：未指定配色方案，应当仅使用默认配色方案进行渲染<br> [light | dark]+：文档支持的一种或多种配色方案，优先第一种。<br> only light：仅支持浅色模式（浅色背景，深色前景）</p></li><li><p>CSS设备适配规范定义的标准名称<br>viewport<br>viewport：为视口的初始大小提供指示，目前仅用于移动设备，其可选的值有：<br>width：定义视口的宽度，可能的值：<br>一个正整数。（此时单位为像素）<br>一个字符串。（带单位的CSS宽度值）<br>device-width 表示与设备宽度一致<br>height： 定义viewport的高度，未被任浏览器使用，不介绍值了<br>initial-scale：定义设备宽度（与横竖屏相关）与视口大小之间的比例<br>是一个0.0-10.0之间的【正数】；<br>maximum-scale： 定义缩放的最大值，必须大于等于minimum-scale<br>是一个0.0-10.0之间的【正数】；<br>minimum-scale：定义缩放的最小值，必须小于等于maximum-scale<br>是一个0.0-10.0之间的【正数】；<br>user-scalable：用户是否可以缩放当前页面<br>yes 或 no ，默认为yes<br>viewport-fit ： 视口是否根据设备自适应，可能的值<br>auto：不会影响“初始布局”视口，整个网页都是可查看的<br>caontain：视口被缩放以适合显示中内接的最大矩形<br>cover： 缩放视口以填充设备显示。<br>将 user-scalable 设置为 no 会阻止一切意义上的缩放，视力不好的人可能会因此无法阅读和理解页面内容</p></li><li><p>其它元数据名称<br>creator：当前文档的创建者，例如某个组织或者机构。如果有不止一个创建者，则应当使用多个名称为 creator 的 <meta> 元素<br>googolbot：robots 的替代名称，只被 Googlebot（Google 的网页爬虫&#x2F;索引搜寻器）使用<br>publisher：当前文档的发布者&#x2F;出版者<br>robots：爬虫应当遵守的规则。是一个使用逗号分隔的、由下列值构成的列表：<br>index：允许爬虫索引此页面（所有爬虫）<br>noindex：要求爬虫不索引此页面（所有爬虫）<br>follow ：允许爬虫跟踪页面上链接所指向的页面（所有爬虫）<br>onfollow：要求爬虫不跟踪页面上的链接（所有爬虫）<br>all：与index,follow 等价（只针对谷歌爬虫）<br>none：与noindex, nofollow等价（只针对谷歌爬虫）<br>noarchive：要求搜索引擎不缓存页面内容（针对谷歌、雅虎、必应搜索）<br>nosnippet：要求搜索引擎不要在搜索结果页显示本页面的描述。（针对谷歌、必应搜索）<br>noimageindex：要求本页面不会成为搜索结果页中索引图像的引用页。（只针对谷歌搜索）<br>nocache：noarchive的替代名称。（只针对必应）</p></li></ol><h5 id="3-http-equiv属性，content属性"><a href="#3-http-equiv属性，content属性" class="headerlink" title="3.http-equiv属性，content属性"></a>3.http-equiv属性，content属性</h5><p>http-equiv 属性用来覆盖 HTTP 回应的头信息字段，content 属性是该字段的内容。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Content-Security-Policy<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>default-src 'self'<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面代码可以覆盖 HTTP 回应的 Content-Security-Policy 字段。</p><h4 id="lt-title-gt-标签"><a href="#lt-title-gt-标签" class="headerlink" title="&lt;title&gt; 标签"></a><code>&lt;title&gt;</code> 标签</h4><p>此标签用于指定页面的标题，会显示在浏览器窗口的标题栏</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>网页标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>搜索引擎根据它排序</p><p>这个标签的内部不能放置其他标签，只能放置无格式的纯文本</p><h4 id="lt-body-gt-标签"><a href="#lt-body-gt-标签" class="headerlink" title="&lt;body&gt; 标签"></a><code>&lt;body&gt;</code> 标签</h4><p><code>&lt;body&gt;</code> 标签是一个容器标签，用于放置网页的主体内容。浏览器显示的页面内容，都是放置在它的内部。它是<code>&lt;html&gt;</code> 的第二个子元素，紧跟在<code>&lt;head&gt;</code> 后面</p><h2 id="1-4空格和换行"><a href="#1-4空格和换行" class="headerlink" title="1.4空格和换行"></a>1.4空格和换行</h2><p>heml里的多个空格和换行最后只会被合并为一个</p><h2 id="1-5注释"><a href="#1-5注释" class="headerlink" title="1.5注释"></a>1.5注释</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 这是一个注释 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者是</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--&lt;p>HelloWorld!&lt;/p>--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML第一章-1</title>
      <link href="/2023/04/14/html-di-yi-zhang-1/"/>
      <url>/2023/04/14/html-di-yi-zhang-1/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h1 id="1-HTML简介"><a href="#1-HTML简介" class="headerlink" title="1.HTML简介"></a>1.HTML简介</h1><h2 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h2><p>浏览器的网页开发涉及3种技术：HTML、CSS、JavaScript</p><ul><li>HTML：定义网页的结构和内容</li><li>CSS：定义网页的样式</li><li>JavaScript：定义网页与用户的互动行为</li></ul><p>基础网页的HTML源码</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;    &lt;title&gt;网页标题&lt;&#x2F;title&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;    &lt;p&gt;Hello World&lt;&#x2F;p&gt;  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2网页的基本概念"><a href="#1-2网页的基本概念" class="headerlink" title="1.2网页的基本概念"></a>1.2网页的基本概念</h2><h3 id="1-2-1标签"><a href="#1-2-1标签" class="headerlink" title="1.2.1标签"></a>1.2.1标签</h3><p>HTML代码由许多的不同标签（tag）组成</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>网页标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>        HelloWorld!    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的就是一些标签，有的标签是成对出现的，例如<code>&lt;title&gt;&lt;/title&gt;</code> <code>&lt;div&gt;&lt;/div&gt;</code>，但有的只出现一个例如说<code>&lt;meta = ……&gt;</code> 因为这只需要一个标签就可以完成功能。</p><p><strong>值得一提的是，在html中可以将代码写到一行里，且对大小写不敏感</strong></p><p>所以有时候在发布网页之前开发者会把源码压缩成一行，以减少传输的字节数。网页内容的缩进和换行主要靠<code>CSS</code> 样式来实现</p><h3 id="1-2-2元素"><a href="#1-2-2元素" class="headerlink" title="1.2.2元素"></a>1.2.2元素</h3><p>浏览器渲染网页的时候，会把html源码解析成一个标签树，每个标签都是一个节点（node），成为网页元素（element）。</p><p>所以标签和元素基本上是同义词，只是使用的场合不一样，标签是源码角度来看，元素是编程角度来看，例如<code>&lt;p&gt;</code> 标签对应网页的<code>p</code>元素。</p><p>而嵌套的标签就构成了网页元素的层级关系</p><p>元素分类:</p><ul><li><p>块级元素（block）</p></li><li><p>行内元素（inline）</p><p>  其中块级元素默认占据一个独立的区域，在网页上会自动另起一行，占据100%的宽度</p></li></ul><h3 id="1-2-3属性"><a href="#1-2-3属性" class="headerlink" title="1.2.3属性"></a>1.2.3属性</h3><p>属性（attribute）是<code>标签</code> 的额外信息，使用空格与标签名和其他属性分隔</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>demo.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>&lt;img&gt;</code> 标签有两个属性：src、width</p><h2 id="1-3网页的基本标签"><a href="#1-3网页的基本标签" class="headerlink" title="1.3网页的基本标签"></a>1.3网页的基本标签</h2><p>主要标签：<code>&lt;!doctype&gt;</code> 此标签标示文档类类型，告诉浏览器如何解析万个亿</p><p>常用**<!DOCTYPE html>**</p><h4 id="lt-html-gt-标签"><a href="#lt-html-gt-标签" class="headerlink" title="&lt;html&gt;标签"></a><code>&lt;html&gt;</code>标签</h4><p><code>&lt;html&gt;</code> 标签是网页的顶层容器，也称为根元素（root element），其他元素都是它的子元素。一个网页只能有一个<code>&lt;html&gt;</code> 标签</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述代码表示网页内容默认为英语</p><h4 id="lt-head-gt-标签"><a href="#lt-head-gt-标签" class="headerlink" title="&lt;head&gt; 标签"></a><code>&lt;head&gt;</code> 标签</h4><head>标签是一个容器标签用于放置网页的元信息。它的内容不会出现在网页上，而是为网页渲染做准备<p>head是<html>的第一个子元素，如何网页不包含<head>，浏览器会自动创建一个</p><p>head的子元素一般有七个</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td><code>&lt;meta&gt;</code></td><td>设置网页的元数据</td></tr><tr><td><code>&lt;link&gt;</code></td><td>链接外部样式表</td></tr><tr><td><code>&lt;title&gt;</code></td><td>设置网页标题</td></tr><tr><td><code>&lt;style&gt;</code></td><td>放置内嵌的样式表</td></tr><tr><td><code>&lt;script&gt;</code></td><td>引入脚本</td></tr><tr><td><code>&lt;noscript&gt;</code></td><td>浏览器不支持脚本时，所要显示的内容</td></tr><tr><td><code>&lt;base&gt;</code></td><td>设置网页内部相对URL的计算基准</td></tr></tbody></table><h4 id="lt-meta-gt-标签"><a href="#lt-meta-gt-标签" class="headerlink" title="&lt;meta&gt; 标签"></a><code>&lt;meta&gt;</code> 标签</h4><p>此标签用于设置或说明网页的元数据 ，必须放到<code>&lt;head&gt;</code> 里面，一个<code>&lt;meta&gt;</code> 标签就是一项元数据，网页可以有多个<code>&lt;meta&gt;</code></p><p>一般来说网页应该有两个meta标签，放到head标签最前面</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-charset属性"><a href="#1-charset属性" class="headerlink" title="1.charset属性"></a>1.charset属性</h5><p>charset属性用于指定网页的编码方式</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述代码声明网页为utf-8编码，虽然可以使用其他编码方式，但主要应该使用utf-8编码、</p><h5 id="2-name属性，content属性"><a href="#2-name属性，content属性" class="headerlink" title="2.name属性，content属性"></a>2.name属性，content属性</h5><p>name属性表示元数据的名字，content属性表示元数据的值</p><p>例如</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>description<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTML 语言入门<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>keywords<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTML,教程<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>author<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>张三<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码包含了三个元数据：</p><ul><li>description：网页内容的描述</li><li>keywords：网页内容的关键字</li><li>auther：网页作者</li></ul><p>meta标签是一个辅助性的标签，在网页上<strong>不可见</strong></p><p>name标签是描述网页的，以便于搜索机器人（搜索引擎）进行查找、分类，目前几乎所有的搜索引擎都使用网上机器人自动查找meta值来给网页分类</p><p>这里要详细讲一下，name属性分类两种</p><ul><li>标准元数据</li><li>用户自定义内容</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主页</title>
      <link href="/2023/04/10/zhu-ye/"/>
      <url>/2023/04/10/zhu-ye/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/10/hello-world/"/>
      <url>/2023/04/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
